#Overview
##Aim
* practical knowledge of standard data structures and algorithms

##Calendar and Schedule
* 3 lectures + 1 tutorial + 1 lab per week
* Put times here when confirmed
* About ~8 assignments

Week Starting | Topics | Assignment
--------------|--------|-----------
date          | topics        | memory refresher
date          | topics        | memory refresher
date          | topics        | stacks/queues/lists
date          | topics        | stacks/queues/lists
date          | topics        | trees and graphs
date          | topics        | trees and graphs
date          | topics        | sorting
date          | topics        | sorting
date          | reading week  | searching
date          | topics        | searching
date          | topics        | hashing
date          | topics        | hashing
date          | review        | 
date          | exam break    | -


##Contents
* Structured types. Array, list, tree, and graph algorithms.
* Hash tables. Dynamic data structures. Abstract data types.
* Lots of practical lab work and skill development.

##Outcomes
1. know a complement of data structures and algorithms
2. understand which are more appropriate for given project
3. implement both efficiently
4. discuss size and computational cost and complexity of different approaches
5. strong code and analytical habits and code simiplification
6. able to employ a variety of profiling, debugging, and optimisation tools

##Good Habits
* Maintain a `my_name.c` set of utility data structures and functions.
* Build up a folder of test/experiment/demo projects e.g. on GitHub.
* Make time to practice 30mins-1hr per day, always.
* Read experts' code. Find their GitHub accounts etc. Ask. Steal their tricks.
* Work on projects with other people.

##Discussion Questions
* what is the fundamental task of a computer program?

* fundamental task of a computer program
  - transform data from input form to output form
  - algorithms formalise ordered transformation steps
  - data is structured by us to
    - help algorithm
    - represent input or output formats
    - make it easier to understand
    - perform better w/respect to computer hardware

* what are current graduates bad at?
  - interviews
  - computer science fundamentals
  - understanding hardware
  - low-level programming techniques
  - data

* why?
  - very broad range of software development skills
  - risk of very thin layer (not deep enough knowledge)
  - over-engineering
  - post-dot com era abstraction/"top-down" thinking
  - dependent on libraries/frameworks/stacks made by others
  - hours of experience

* goals of course
  1. beef up low-level programming competency
  2. practical knowledge of fundamental DS&A
  3. knowing /when/ and /why/ to introduce complexity
  4. finding the simplest solution
  5. formal analysis techniques
  6. optimisation and practical tools

-------------------------------------------------------

Refreshing C Programming
------------------------
* role of language, compiler, linker
* basic program structure
* headers, c files conventions, pragma, no code in header
* C99 (ignoring C++ for now)
* good habits, using blocks rather than lots of tiny functions
* memory allocation and deallocation
* pointers are not arrays
* pointers and addresses, dereferencing chains
* memory size and stride
* reading and writing
* structs
* copying memory using memcpy()
* debugging, backtraces, finding leaks
* inline functions
* profiling
* timers

First assignment/lab
--------------------
- self-assessment survey
- setting up compile environment with C
- memory allocation and looping over arrays
  + timers and simple analysis
- formal report/summary of program
- .c file
- grading rubrik similar to berkeley's
