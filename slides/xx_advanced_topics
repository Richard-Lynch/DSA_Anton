* undestanding the memory-cache levels-registers
* cost of various instructions for particular architectures
* cost of calling a function
* understanding compiled assembler/intermediate
* this thing is great https://gcc.godbolt.org/
* instruction tables and opt guidelines for programmers http://www.agner.org/optimize/
* also see intel/amd manuals

## cache coherency

* thinking about data
* hardware changes / fast multi-core vs. same old slow memory
* show how big cache is
* cache misses and hits
* demonstrate rearrangement benefit
* at odds with OOP design
* ~20x faster
* case study - exterminator 2gb file text editor is instant vs crash VS and extremely slow XCode
